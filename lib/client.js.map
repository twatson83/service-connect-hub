{"version":3,"sources":["../src/client.js"],"names":["connect","addHandler","removeHandler","clearHandlers","setContext","send","sendRequest","publish","socket","requestCallbacks","requestCounter","handlers","url","on","message","type","callbacks","forEach","cb","console","info","key","emit","headers","callback","Promise","resolve","reject","ex","push","filter","length","Object","keys","t","context","endpoint"],"mappings":"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","file":"client.js","sourcesContent":["import io from \"socket.io-client\";\r\n\r\nlet socket,\r\n    requestCallbacks = {},\r\n    requestCounter = 0;\r\n\r\nexport let handlers = {};\r\n\r\n/**\r\n * Connects to server\r\n * @param  {string} url\r\n */\r\nexport function connect(url) {\r\n\r\n    if(url){\r\n        socket = io(url);\r\n    } else {\r\n        socket = io();\r\n    }\r\n\r\n    // Received from the server when a message has been consumed.  Executed all the callbacks that are interested in\r\n    // message type.\r\n    socket.on(\"handler-message\", (message, type) => {\r\n        var callbacks = handlers[type];\r\n        if (callbacks){\r\n            callbacks.forEach(cb => cb(message, type));\r\n        }\r\n    });\r\n\r\n    socket.on(\"reconnect\", () => {\r\n        console.info(\"Re-registering handlers with server\");\r\n        for(var key in handlers){\r\n            socket.emit(\"add-handler\", key);\r\n        }\r\n    });\r\n\r\n    socket.on(\"response\", (message, type, headers) => {\r\n        var callback = requestCallbacks[headers[\"ClientId\"]];\r\n        if (callback){\r\n            callback(message, type, headers);\r\n            delete requestCallbacks[headers[\"ClientId\"]];\r\n        }\r\n    });\r\n\r\n    return new Promise((resolve, reject) => {\r\n        socket.on('connect', () => {\r\n            resolve();\r\n        });\r\n        socket.on('connect_error', (ex) => {\r\n            reject(ex);\r\n        });\r\n    });\r\n}\r\n\r\n/**\r\n * Begins listening for messages of type @type.  Will execute @callback when a message is received of type @type.\r\n * @param  {string} type\r\n * @param  {function} callback\r\n */\r\nexport function addHandler(type, callback) {\r\n    handlers[type] = handlers[type] || [];\r\n    handlers[type].push(callback);\r\n\r\n    // Tells the server we are interested in the type.\r\n    socket.emit(\"add-handler\", type);\r\n}\r\n\r\n/**\r\n * Unbinds the type and callback and stops listening for the message type if no more callbacks are bound to the type.\r\n * @param  {string} type\r\n * @param  {function} callback\r\n */\r\nexport function removeHandler(type, callback) {\r\n    // Remove callback from the map\r\n    handlers[type] = handlers[type].filter(cb => {\r\n        return cb !== callback;\r\n    });\r\n\r\n    // Unbinds handler from client on server\r\n    if (handlers[type].length === 0){\r\n        socket.emit(\"remove-handler\", type);\r\n    }\r\n}\r\n\r\n/**\r\n * Removes all handler bindings\r\n */\r\nexport function clearHandlers() {\r\n\r\n    Object.keys(handlers).forEach(t => {\r\n        socket.emit(\"remove-handler\", t);\r\n        delete handlers[t];\r\n    });\r\n}\r\n\r\n/**\r\n * Sets the context on the server.  Server can use the context to filter messages.\r\n * @param  {object} context\r\n */\r\nexport function setContext(context) {\r\n    socket.emit(\"set-context\", context);\r\n}\r\n\r\n/**\r\n * Sends a command to the specified endpoint(s).\r\n * @param {String|Array} endpoint\r\n * @param  {String} type\r\n * @param  {Object} message\r\n * @param  {Object|undefined} headers\r\n */\r\nexport function send(endpoint, type, message, headers = {}){\r\n    socket.emit(\"send-command\", endpoint, type, message, headers);\r\n}\r\n\r\n/**\r\n * Sends a command to the specified endpoint(s) and waits for one or more replies.\r\n * The method behaves like a regular blocking RPC method.\r\n * @param {string|Array} endpoint\r\n * @param {string} type\r\n * @param {Object} message\r\n * @param {function} callback\r\n * @param {Object|undefined} headers\r\n */\r\nexport function sendRequest(endpoint, type, message, callback, headers = {}){\r\n    requestCallbacks[requestCounter] = callback;\r\n    headers[\"ClientId\"] = requestCounter;\r\n    requestCounter++;\r\n    socket.emit(\"send-request\", endpoint, type, message, headers);\r\n}\r\n\r\n/**\r\n * Published an event of the specified type.\r\n * @param  {String} type\r\n * @param  {Object} message\r\n * @param  {Object|undefined} headers\r\n */\r\nexport function publish(type, message, headers = {}){\r\n    socket.emit(\"publish-event\", type, message, headers);\r\n}"]}