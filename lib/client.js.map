{"version":3,"sources":["../src/client.js"],"names":["connect","addHandler","removeHandler","setContext","send","sendRequest","publish","socket","requestCallbacks","requestCounter","handlers","url","on","message","type","callbacks","forEach","cb","console","info","key","emit","headers","callback","push","filter","length","context","endpoint"],"mappings":"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","file":"client.js","sourcesContent":["import io from \"socket.io-client\";\r\n\r\nlet socket,\r\n    requestCallbacks = {},\r\n    requestCounter = 0;\r\n\r\nexport let handlers = {};\r\n\r\n/**\r\n * Connects to server\r\n * @param  {string} url\r\n */\r\nexport function connect(url) {\r\n    socket = io.connect(url);\r\n\r\n    // Received from the server when a message has been consumed.  Executed all the callbacks that are interested in\r\n    // message type.\r\n    socket.on(\"handler-message\", (message, type) => {\r\n        var callbacks = handlers[type];\r\n        if (callbacks){\r\n            callbacks.forEach(cb => cb(message, type));\r\n        }\r\n    });\r\n\r\n    socket.on(\"reconnect\", () => {\r\n        console.info(\"Re-registering handlers with server\");\r\n        for(var key in handlers){\r\n            socket.emit(\"add-handler\", key);\r\n        }\r\n    });\r\n\r\n    socket.on(\"response\", (message, type, headers) => {\r\n        var callback = requestCallbacks[headers[\"ClientId\"]];\r\n        if (callback){\r\n            callback(message, type, headers);\r\n            delete requestCallbacks[headers[\"ClientId\"]];\r\n        }\r\n    });\r\n}\r\n\r\n/**\r\n * Begins listening for messages of type @type.  Will execute @callback when a message is received of type @type.\r\n * @param  {string} type\r\n * @param  {function} callback\r\n */\r\nexport function addHandler(type, callback) {\r\n    handlers[type] = handlers[type] || [];\r\n    handlers[type].push(callback);\r\n\r\n    // Tells the server we are interested in the type.\r\n    socket.emit(\"add-handler\", type);\r\n}\r\n\r\n/**\r\n * Unbinds the type and callback and stops listening for the message type if no more callbacks are bound to the type.\r\n * @param  {string} type\r\n * @param  {function} callback\r\n */\r\nexport function removeHandler(type, callback) {\r\n    // Remove callback from the map\r\n    handlers[type] = handlers[type].filter(cb => {\r\n        return cb !== callback;\r\n    });\r\n\r\n    // Unbinds handler from client on server\r\n    if (handlers[type].length === 0){\r\n        socket.emit(\"remove-handler\", type);\r\n    }\r\n}\r\n\r\n/**\r\n * Sets the context on the server.  Server can use the context to filter messages.\r\n * @param  {object} context\r\n */\r\nexport function setContext(context) {\r\n    socket.emit(\"set-context\", context);\r\n}\r\n\r\n/**\r\n * Sends a command to the specified endpoint(s).\r\n * @param {String|Array} endpoint\r\n * @param  {String} type\r\n * @param  {Object} message\r\n * @param  {Object|undefined} headers\r\n */\r\nexport function send(endpoint, type, message, headers = {}){\r\n    socket.emit(\"send-command\", endpoint, type, message, headers);\r\n}\r\n\r\n/**\r\n * Sends a command to the specified endpoint(s) and waits for one or more replies.\r\n * The method behaves like a regular blocking RPC method.\r\n * @param {string|Array} endpoint\r\n * @param {string} type\r\n * @param {Object} message\r\n * @param {function} callback\r\n * @param {Object|undefined} headers\r\n */\r\nexport function sendRequest(endpoint, type, message, callback, headers = {}){\r\n    requestCallbacks[requestCounter] = callback;\r\n    headers[\"ClientId\"] = requestCounter;\r\n    requestCounter++;\r\n    socket.emit(\"send-request\", endpoint, type, message, headers);\r\n}\r\n\r\n/**\r\n * Published an event of the specified type.\r\n * @param  {String} type\r\n * @param  {Object} message\r\n * @param  {Object|undefined} headers\r\n */\r\nexport function publish(type, message, headers = {}){\r\n    socket.emit(\"publish-event\", type, message, headers);\r\n}"]}