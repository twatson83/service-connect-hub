{"version":3,"sources":["../src/server.js"],"names":["Bus","require","ServiceConnectHub","options","connections","_connected","bind","_emitMessage","init","_removeTypeMapping","_typeStillMapped","_getFiltersByType","on","console","log","server","callback","bus","emit","ex","socketServer","socket","id","handlers","context","_isValidMessageType","handler","push","isHandled","addHandler","filter","h","endpoint","type","message","headers","send","publish","sendRequest","undefined","key","blacklist","includes","whitelist","isMapped","removeHandler","connectionKey","filters","shouldProcess","every","f","RegExp","test"],"mappings":"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","file":"server.js","sourcesContent":["import io from \"socket.io\";\r\nvar Bus = require(\"service-connect\");\r\nimport EventEmitter from \"events\";\r\n\r\n/** Class representing a the server implementation of ServiceConnectHub. */\r\nexport class ServiceConnectHub extends EventEmitter {\r\n\r\n    /**\r\n     * Sets config and creates socket server.  Then starts data sources and begins listening for client connections.\r\n     * @constructor\r\n     * @param  {object} options\r\n     */\r\n    constructor(options){\r\n        super();\r\n        this.options = options;\r\n        this.connections = {};\r\n        this._connected = this._connected.bind(this);\r\n        this._emitMessage = this._emitMessage.bind(this);\r\n        this.init = this.init.bind(this);\r\n        this._removeTypeMapping = this._removeTypeMapping.bind(this);\r\n        this._typeStillMapped = this._typeStillMapped.bind(this);\r\n        this._getFiltersByType = this._getFiltersByType.bind(this);\r\n        this.on(\"error\", console.log);\r\n    }\r\n\r\n    /**\r\n     * Initializes the web socket connection and service connect bus. Calls callback when connected.\r\n     * @param server\r\n     * @param {function} callback\r\n     */\r\n    init(server, callback){\r\n        this.bus = new Bus(this.options.bus);\r\n        this.bus.on(\"error\", ex => this.emit(\"error\", ex));\r\n        this.bus.on(\"connected\", ex => this.emit(\"connected\", ex));\r\n\r\n        this.bus.init(() =>{\r\n            this.socketServer = io(server);\r\n            this.socketServer.on(\"connection\", this._connected);\r\n            this.socketServer.on(\"error\", ex => this.emit(\"error\", ex));\r\n\r\n            if (callback){\r\n                callback();\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Called by socket.io when client connects.  Sets up event handlers for add-handler, remove-handler and disconnect.\r\n     *\r\n     * set-context callback will register client context object with socket connection.  Potential uses of context are\r\n     * security token.  Can be used in conjunction with filters to filter messages based on client context.\r\n     *\r\n     * add-handler callback will bind the type to the client socket id.  It first checks handler type against a white\r\n     * list and black list.\r\n     *\r\n     * remove-handler callback removed the handler type mapping from the client.  If no clients are handling the type\r\n     * it will remove the Bus type binding.\r\n     *\r\n     * disconnect callback removed the client from the handlers map.\r\n     * @param  {object} socket\r\n     * @private\r\n     */\r\n    _connected(socket){\r\n        this.connections[socket.id] = { socket, handlers: [] };\r\n\r\n        socket.on(\"set-context\", context => {\r\n            this.connections[socket.id].context = context;\r\n        });\r\n\r\n        socket.on(\"error\", ex => {\r\n            this.emit(\"error\", ex);\r\n        });\r\n\r\n        socket.on(\"add-handler\", handler => {\r\n            if(!this._isValidMessageType(handler))\r\n                return;\r\n\r\n            this.connections[socket.id].handlers.push(handler);\r\n\r\n            if (!this.bus.isHandled(handler)){\r\n                this.bus.addHandler(handler, this._emitMessage);\r\n            }\r\n        });\r\n\r\n        socket.on(\"remove-handler\", handler => {\r\n            this.connections[socket.id].handlers = this.connections[socket.id].handlers.filter(h => h !== handler);\r\n            this._removeTypeMapping(handler);\r\n        });\r\n\r\n        socket.on(\"send-command\", (endpoint, type, message, headers) => {\r\n            if(!this._isValidMessageType(type))\r\n                return;\r\n\r\n            this.bus.send(endpoint, type, message, headers);\r\n        });\r\n\r\n        socket.on(\"publish-event\", (type, message, headers) => {\r\n            if(!this._isValidMessageType(type))\r\n                return;\r\n\r\n            this.bus.publish(type, message, headers);\r\n        });\r\n\r\n        socket.on(\"send-request\", (endpoint, type, message, headers) => {\r\n            if(!this._isValidMessageType(type))\r\n                return;\r\n\r\n            this.bus.sendRequest(endpoint, type, message, message => {\r\n                socket.emit(\"response\", message, type, headers);\r\n            }, headers);\r\n        });\r\n\r\n        socket.on(\"disconnect\", () => {\r\n            if(this.connections[socket.id] !== undefined){\r\n                for (var key in this.connections[socket.id]){\r\n                    this._removeTypeMapping(key);\r\n                }\r\n                delete this.connections[socket.id];\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Returns true is message type is not on black list and if white list is populated is on white list\r\n     * @param {string} type\r\n     * @private\r\n     */\r\n    _isValidMessageType(type){\r\n        if(this.options.blacklist && this.options.blacklist.includes(type))\r\n            return false;\r\n\r\n        // Return if not on white list?\r\n        if(this.options.whitelist && !this.options.whitelist.includes(type))\r\n            return false;\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Remove type mapping from client if no more clients are interested in message\r\n     * @param {string} type\r\n     * @private\r\n     */\r\n    _removeTypeMapping(type){\r\n        var isMapped = this._typeStillMapped(type);\r\n        if(!isMapped){\r\n            this.bus.removeHandler(type, this._emitMessage);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Finds if type is still mapped\r\n     * @param {String} type\r\n     * @return {boolean}\r\n     * @private\r\n     */\r\n    _typeStillMapped(type){\r\n        for (var connectionKey in this.connections){\r\n            if (this.connections[connectionKey].handlers.includes(type)){\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Called when the Bus received a message.  Checks if the message should be processed and then processes message.\r\n     * @param  {object} message\r\n     * @param  {object} headers\r\n     * @param  {string} type\r\n     * @private\r\n     */\r\n    _emitMessage(message, headers, type){\r\n        let filters = this._getFiltersByType(type);\r\n\r\n        for (let key in this.connections) {\r\n            if(this.connections[key].handlers.includes(type)){\r\n                let shouldProcess = filters.every(f => f(message, headers, type, this.connections[key].context));\r\n                if (shouldProcess){\r\n                    this.connections[key].socket.emit(\"handler-message\", message, type, headers);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns filters that match the type.\r\n     * @param {string} type\r\n     * @return {Array} filters\r\n     * @private\r\n     */\r\n    _getFiltersByType(type) {\r\n        var filters = [];\r\n        if (this.options.filters) {\r\n            for (let key in this.options.filters) {\r\n                if (new RegExp(key).test(type)) {\r\n                    filters.push(...this.options.filters[key]);\r\n                }\r\n            }\r\n        }\r\n        return filters;\r\n    }\r\n}"]}